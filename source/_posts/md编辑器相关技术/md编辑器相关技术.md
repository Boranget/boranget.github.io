---
title: md编辑器相关技术记录
date: 2024-08-6 17:35:19
updated: 2024-08-6 17:35:19
tags:
  - 编辑器
  - markdown
categories:
  - notes
---

# 参考资料

[从零开始写一个富文本编辑器（一） - 掘金 (juejin.cn)](https://juejin.cn/post/6924346082797289480)

[十分钟实现自己的Typora - 掘金 (juejin.cn)](https://juejin.cn/post/6844903878224412686)

[Selection - Web API | MDN (mozilla.org)](https://developer.mozilla.org/zh-CN/docs/Web/API/Selection)

[Vditor 实现 Markdown 所见即所得 - 链滴 (ld246.com)](https://ld246.com/article/1577370404903)

[关于所见即所得 Markdown 编辑器的讨论 - 链滴 (ld246.com)](https://ld246.com/article/1579414663700)

[剪贴板操作 Clipboard API 教程 - 阮一峰的网络日志 (ruanyifeng.com)](https://www.ruanyifeng.com/blog/2021/01/clipboard-api.html)

# Selection

Selection中存储用户选择的文本范围或者插入符号的位置，获取方式：`window.getSelection()`

在不可编辑元素中，插入点位置和选区范围必须通过鼠标的点击或者拖拽产生，在可编辑元素中，插入点位置和选取范围也可以通过键盘方向键变化。

可通过`window.getSelection().toString()`获取被选中的文字

# Range

可通过`selection.getRangeAt`获取

- `Range.commonAncestorContainer`返回完整包含所选内容的最深一层的节点

# designMode

document的designMode属性，可以将整个页面开启编辑模式，类似于给整个页面加上了`contentEditable="true"`属性。

设置方式如：

`document.designMode = "on";`

可选值有`on`和`off`

设置iframe可编辑：

`iframeNode.contentDocument.designMode = "on";`

可以将编辑区设为iframe

# contentEditable

该属性用于开启某个元素的可编辑：

- `"true"` 表明该元素可编辑。
- `"false"` 表明该元素不可编辑。
- `"plaintext-only"` 表明该元素可以纯文本格式编辑，富文本格式会被禁用。
- `"inherit"` 表明该元素继承了其父元素的可编辑状态。

```js
editable = element.contentEditable
element.contentEditable = "true"
```

# 选中复制

复制html页面时，复制到的内容为标签中间的内容，也就是innerText，也包括可编辑内容如输入框的value

# 一些事件监听器

同一元素同一类型的事件监听器可以注册多个

## input

在可编辑元素或者开启了可编辑的元素上添加监听器监听input事件

## beforeinput

会在元素编辑前触发，此时e中的target为编辑前的状态，但在该事件中无法阻止输入的执行

## selectionchange

会在selection变化时触发，包括选区变化，点击了新的位置或者输入了新的内容

# 思路记录

使用抽象语法树来分析整个文档，或者使用抽象语法树的时候要不要将h2与h1（等情况）的层级关系抽象到语法树中。

目前看来md最合适的方式是所有的元素都在一个层级，比如标题、与标题下的正文，这些元素应该是在同一个层级就可以（抽象为一个一个块），这样在进行标题的添加与删除时，不会导致整个文档的语法树层级变化太大，而对每一块做编辑的时候，每次只需要重新渲染当前块即可，这样变化量较小

每次input事件被触发时，获取当前range，获取选区内的对象内容，接着重新渲染这部分内容，渲染完成后重置光标

如果是先选中一部分选区后，做删除或者替换操作，则在input之前（beforeinput事件）通过range判断选中的范围（影响的块），在input后再根据具体的操作，则获取这个选取内的所有块的文本后进行重新渲染，如果是添加也一样，此时肯定要先将选定范围内容的所有元素都删除再重新渲染

关于块级上下文思路：碰到一个空行后则开启/关闭一个上下文，在上下文中要根据当前上下文渲染样式，比如碰到代码块或者列表这种多行的块结构，特殊情况比如代码块等有标准的块上下文标识的按照具体情况考虑

块内的元素，考虑在块内再加一个小一级的元素，至于块内的内容可以用一个List，List里包含这些元素，叫Token又好像不太符合，可以叫零件[Part]

# 不同元素的块划分

## 标题

标题是比较简单的，碰到`#`后，往后继续看，如果还是#，就放到缓冲区，继续向后看，如果在此时看到了空格，则当前行为标题，如果遇到既不是`#`也不是空格的情况，则当正文处理

## 段落

碰到空行后，上方与下方都单独形成一个块，前提是当前上下文环境非围栏代码块，且当前空行也可作为一个块

## 换行

碰到两个空格+一个回车符号的时候，生成一个\<br/\>标签，渲染时直接将br标签加到上一个块的末尾。在生成块元素时，可以作为行内零件放在最后。

## 强调语法

强调语法同样是行内零件：

这里可以使用栈，构造一个强调语法栈，

碰到星号/下划线后，提前预读下一个字符，下一个字符如果还是星号，形成粗体标识，否则形成斜体标识，此时判断栈顶元素？不太合理，比如`**123*`的情况，应该渲染`*123`为斜体，但如果提前确认前面的为粗体标识就误判了，至于**123*123**，则应该将中间的部分`123*123`都加粗。

应该这样：碰到一个星号的时候，开启一个斜体上下文，同时保持记录正文，如果下一个字符是星号，就继续开启一个粗体上下文，但不关闭斜体上下文，接着在当前块往下读，当读到一个星号时，则继续向下预读一个字符，如果是星号，则形成粗体零件，如果下一个字符不是星号，则形成斜体零件。

对比Typora，似乎粗体上下文比斜体有着更高的优先级，匹配成功斜体零件后，粗体并不会立即关闭，直到碰到下一个粗体标识或者当前块结束。甚至在粗体上下文存在时，如果匹配到斜体的星号，还会再开启一个斜体上下文。

。。。。。。。太复杂了

## 引用

某行开头若碰到`>`符号，则当前行为引用格式，

引用为多行一块的形式：多行如果都为引用开头，则这些行都在同一个引用块中，所以当碰到`>`开头的行时，应该开启一个引用上下文，直到下一行不是`>`开头。

引用块中的内容可以继续渲染md：将去掉行开始字符的内容作为正文，那就说明，引用块不会影响其他块比如标题（需要#开头），但引用块中的标题不会体现在导航栏。 

## 有序列表

数字加一个点再加一个空格开头的行作为有序列表，同样的应该开启一个有序列表的上下文，这里要注意有序列表存在嵌套的情况，所以如果某一行开头是空格，接着出现有序列表标识，则需要记录当前有序列表开头的空格数，作为当前有序列表的层级标识。如果碰到当前层级比上一行的有序列表层级低，则新开一个上下文，直到碰到高于当前层级的有序列表才关闭。

## 无序列表

类似有序列表，不过开头非数字而是如下字符:`-`, `*`, `+`

## 列表中包含其他元素

类似于引用块的封装

## 代码

代码为行内零件，可以采取就近原则，发现一个`符号后则开启代码上下文，同时保持记录正文，直到发现下一个代码符号或者当前行结束。

## 代码块

将代码的每一行开头都使用四个空格或者一个制表符缩进，类似于引用的处理。

## 分割线

在单独的一个块中使用三个以上的如下符号可创建一条分割线：`*`,`-`,`_`，不包含其他内容（空格及制表符除外）

